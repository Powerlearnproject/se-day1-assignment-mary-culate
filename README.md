[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15567641&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment
   
#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
  
  Software engineering is the branch of computer science that deals with the design, development, testing, and maintenance of software applications. Software engineers apply engineering   principles and knowledge of programming languages to build software solutions for end users.
Software engineering has become increasingly significant in today’s digital age.The extensive use of technology in various sectors, such as healthcare, finance, and transportation, has led to a growing demand for innovative and reliable software solutions.From streaming services to video games, software engineers are at the forefront of creating immersive and interactive experiences for users worldwide, making software engineering important in many industries, including the entertainment industry.The development of special effects, realistic graphics, and seamless user interfaces relies heavily on the expertise of software engineers.

Identify and describe at least three key milestones in the evolution of software engineering.

1948: Grace Hopper develops the first compiler, which translates human-readable code into machine code.
1957: FORTRAN, the first high-level programming language, is released.
1960s: The term "software engineering" is coined.
Software engineering has evolved into a more formal and structured discipline, the art of software development still plays an important role in the design and development of software systems. It’s the balance of both that leads to successful software development. Software engineering transitioned from being considered an art form to being considered a craft as the field grew more structured, formalized and focused on established processes, methodologies and tools. The goal of software engineering is not only to deliver a functional product but also to deliver a product that is reliable, maintainable and efficient. Treating software development as an engineering discipline can lead to higher quality software that is more reliable, predictable, and maintainable, as well as increased productivity and better cost management.

List and briefly explain the phases of the Software Development Life Cycle.

The Software Development Life Cycle (SDLC) is a systematic approach to software development that typically has seven phases: 
Planning: This phase includes activities like scheduling, cost-benefit analysis, and resource allocation. 
Requirements analysis: This phase involves gathering requirements and analyzing them. 
Design: In this phase, software engineers analyze requirements and identify solutions to create the software. 
Coding or implementation: In this phase, the development team codes the product. 
Testing: In this phase, the development team uses a combination of manual and automated testing to check for bugs. 
Deployment: In this phase, teams code and test on a different copy of the software than the one that users have access to. 
Maintenance: This is the final phase of the SDLC.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

Agile is an approach to project management, specifically software development projects, that prioritizes collaboration, continuous delivery and customer feedback. Agile breaks work into iterative steps, which are smaller tasks that can be completed quickly. These iterations are done during sprints. Agile teams complete one sprint before moving onto the next one. 
Requirements can change at any time in the project based on changing business needs or customer feedback. Future sprints are based on the outcomes of previous
sprints.

Waterfall is an approach to project management and software development that follows a linear sequence of events. In Waterfall, each phase of the project is gated. Teams cannot advance from one phase of the SDLC to the next until the current phase is complete. Each phase has clearly defined completion criteria. Criteria for the project are generated in the first stage of Waterfall -- the requirements stage -- and codified in documentation. The requirements set forth in the beginning ideally do not change during the course of a development project in this model.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

The software developer is responsible for writing the code and developing the entire software product. Aside from coding, a software developer is responsible for sending updates to the project manager and working closely with other team members, including the designer and QA engineer. The kind of software developer you hire for your team depends on your desired software. If you want a mobile application, you need an iOS or an Android developer. However, if you want to develop a web application, you need a front-end, back-end or full-stack developer. 

A Quality Assurance Engineer  monitors every phase of the software development process, including development, testing, debugging and delivery. They ensure that quality is maintained at every stage of the development process and that the final product meets the requirements.

The roles of the project manager may include helping the team to design, execute, monitor and finish their work so that the clients will receive higher-quality software products. 

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

An integrated development environment (IDE) is a software application that helps programmers develop software code efficiently. It increases developer productivity by combining capabilities such as software editing, building, testing, and packaging in an easy-to-use application. Just as writers use text editors and accountants use spreadsheets, software developers use IDEs to make their job easier. Examples of IDEs are Local IDEs and Cloud IDEs.

Version control is defined as a system that tracks the progress of code across the software development lifecycle and its multiple iterations – which maintains a record of every change complete with authorship, timestamp, and other details – and also aids in managing change.Examples of version control system are aew Git, aperche conversion, CMVC, Azure Devops and Github.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges. 

Technology is constantly changing, and engineers need to keep up with new systems and tools.
Customer demands can increase during development, and customers may not be clear about their needs. 
Engineers may have limited time and resources, and may need to meet budget constraints. 
Requirements may change during development, and engineers need to adapt quickly to avoid impacting the project.
New threats and hacking methods appear regularly, so engineers need to ensure their software is secure and regularly checked. 
Businesses may not anticipate which hardware and software users will be using, which can cause integration problems that impact timelines, budgets, and project scope.
As software grows in size and complexity, it can be difficult to identify error-prone modules before testing. This can be costly and time-consuming.
Bugs and shortcuts taken during development can create long-term costs that need to be addressed to ensure the system's stability and reliability. 
Obfuscating code can make it difficult for developers to understand how it works, which can lead to longer development cycles, missed deadlines.
To overcome this challenges,ask enough questions to understand the requirements. Even if it is obvious, make sure to reconfirm your understanding with the PO or tearn the tricks and shortcuts of the tools that you have in your development environment. It will simplify your work and help you increase your output.he client.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Manual testing is done in person, by clicking through the application or interacting with the software and APIs with the appropriate tooling. This is very expensive since it requires someone to setup an environment and execute the tests themselves, and it can be prone to human error as the tester might make typos or omit steps in the test script.
Automated tests, on the other hand, are performed by a machine that executes a test script that was written in advance. These tests can vary in complexity, from checking a single method in a class to making sure that performing a sequence of complex actions in the UI leads to the same results.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering jobs have increased significantly since the launch of generative AI. Prompt engineers bridge the gap between your end users and the large language model. They identify scripts and templates that your users can customize and complete to get the best result from the language models. These engineers experiment with different types of inputs to build a prompt library that application developers can reuse in different scenarios.
Prompt engineering makes AI applications more efficient and effective. Application developers typically encapsulate open-ended user input inside a prompt before passing it to the AI model.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

A vague app idea can be turned into a fully functional software . Think data structures, storage, UI design, scalability, and performance. It's like going from a sketch to a detailed architectural plan.Next, another assistant can be inivited to dissected this plan into a list of clear, actionable tasks. It's the stage where a grand plan gets sliced into bite-sized, doable chunks. The third assistant took these tasks aqre thern turned them into actual code, including a feedback loop for error handling and troubleshooting. This wasn't just automation; it was AI adapting and problem-solving on the fly.




